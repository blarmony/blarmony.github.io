<!--
---
title: "Using WebGL Backgrounds"
date: 2025-05-02
categories: ["webgl"]
tags: ["background", "tutorial"]
---
-->

<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Using WebGL Backgrounds</title>
		<link rel="stylesheet" href="../style.css">
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<!-- Add Prism.js for syntax highlighting -->
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
		<style>
			body {
				margin: 0; 
				display: block;
			}
			#container {
				position: absolute;
				width: 100%;
				height: 100%;
				overflow: hidden;
			}
		</style>
	</head>
	<body class="webgl-background">
		<!-- Container for the WebGL content -->
		<div id="container"></div>

		<main>
			<div class="content-container">
				<h1>Using WebGL Backgrounds</h1>
				
				<p>WebGL backgrounds can add a dynamic, interactive element to your website that traditional CSS cannot achieve. This tutorial will walk you through implementing a WebGL background in a way that's both visually appealing and performance-friendly.</p>

				<h2>Step-by-Step Implementation Guide</h2>
				
				<div class="tutorial-steps">
					<h3>1. Set Up Your Project Structure</h3>
					<ul>
						<li>Create your HTML file</li>
						<li>Link to your CSS file: <code>&lt;link rel="stylesheet" href="../style.css"&gt;</code></li>
						<li>Set up meta tags for proper mobile display</li>
					</ul>

					<h3>2. Add the Basic HTML Structure</h3>
					<ul>
						<li>Add the <code>webgl-background</code> class to your body tag</li>
						<li>Create a container div with id="container" for the WebGL canvas</li>
						<li>Add a main content area with the <code>content-container</code> class</li>
					</ul>

					<h3>3. Include Essential Inline Styles</h3>
					<ul>
						<li>Add minimal inline styles for the body and container</li>
						<li>No need to modify style.css - all WebGL styling is already included!</li>
						<li>The <code>webgl-background</code> class automatically applies all necessary styling</li>
					</ul>

					<h3>4. Set Up Your WebGL Script</h3>
					<ul>
						<li>Import Three.js library</li>
						<li>Create shader code for your effect</li>
						<li>Initialize the WebGL renderer, scene, and camera</li>
						<li>Set up animation loop</li>
					</ul>

					<h3>5. Optimize for Performance</h3>
					<ul>
						<li>Implement device detection for mobile optimization</li>
						<li>Scale resolution based on device capabilities</li>
						<li>Use simpler shaders on mobile devices</li>
						<li>Implement cleanup functions to prevent memory leaks</li>
					</ul>
				</div>

				<h2>Complete Example</h2>
				
				<p>Here's a complete working example that you can use as a starting point. Simply copy this template for any new WebGL background page:</p>
				
				<h3>HTML Structure</h3>
				<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;title&gt;WebGL Background&lt;/title&gt;
    &lt;link rel="stylesheet" href="../style.css"&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;style&gt;
      body {
        margin: 0;
        display: block;
      }
      #container {
        position: absolute;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body class="webgl-background"&gt;
    &lt;div id="container"&gt;&lt;/div&gt;
    &lt;main&gt;
      &lt;div class="content-container"&gt;
        &lt;!-- Your content here --&gt;
      &lt;/div&gt;
    &lt;/main&gt;
    &lt;script src="../menu.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
				
				<h3>CSS in style.css (for reference only - no changes needed)</h3>
				<pre><code class="language-css">/* These styles are already in style.css - you don't need to add them */
/* They're included here just for reference */
.webgl-background {
    height: auto;
    min-height: 100vh;
    overflow-y: auto !important;
}

.webgl-background #container {
    position: fixed;
    width: 100%;
    height: 100%;
    overflow: hidden;
    z-index: -1; /* Place the container behind other elements */
}

.webgl-background header {
    background-color: transparent !important;
    position: absolute;
    width: 100%;
    z-index: 10;
}

.webgl-background .menu {
    background-color: rgba(51, 51, 51, 0.7) !important;
    backdrop-filter: blur(5px);
}

.webgl-background .hamburger {
    position: fixed !important;
    top: 15px !important;
    right: 15px !important;
}

.content-container {
    margin-top: 6rem;
    margin-left: 2rem;
    margin-right: 2rem;
    padding: 2rem;
    max-width: 800px;
    background-color: rgba(59, 58, 54, 0.1);
    backdrop-filter: blur(10px);
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
}</code></pre>
				
				<h2>Performance Considerations</h2>
				<p>WebGL backgrounds can be resource-intensive, especially on mobile devices. Consider these optimizations:</p>
				<ul>
					<li>Pre-render gradient textures or generate them once at startup instead of per-pixel calculations</li>
					<li>Use texture mapping and transformations for better performance</li>
					<li>Implement adaptive complexity based on device capabilities</li>
					<li>Consider using Canvas 2D + CSS animations for simpler effects</li>
					<li>Render to lower resolution textures and upscale for better performance</li>
				</ul>
				
				<p>With these techniques, you can create stunning interactive backgrounds while maintaining good performance across devices.</p>
				</div>
			</main>

			<!-- Vertex shader script -->
			<script id="vertexShader" type="x-shader/x-vertex">
				// Declare varying variable for UV coordinates
				varying vec2 vUv;

				/* 
				 * Main function of the vertex shader
				 * This function is called for each vertex in the geometry
				 */
				void main() {

					/* 
					 * Pass UV coordinates to fragment shader
					 * The UV coordinates are used to determine the texture coordinates
					 */
					vUv = uv;

					/* 
					 * Set the position of the vertex
					 * The position is a 4-component vector (x, y, z, w)
					 * where w is the homogeneous coordinate
					 */
					gl_Position = vec4( position, 1.0 );

				}
			</script>

			<!-- Fragment shader script -->
			<script id="fragmentShader" type="x-shader/x-fragment">
				// Receive UV coordinates from vertex shader
				varying vec2 vUv;

				/* 
				 * Uniform variable for animation timing
				 * This variable is updated by the JavaScript code
				 */
				uniform float time;

				/* 
				 * Main function of the fragment shader
				 * This function is called for each pixel in the geometry
				 */
				void main() {

					/* 
					 * Calculate the position of the pixel in the 2D space
					 * The position is a 2-component vector (x, y)
					 */
					vec2 p = - 1.0 + 2.0 * vUv;

					/* 
					 * Calculate the animation timing
					 * The animation timing is used to animate the pattern
					 */
					float a = time * 40.0;

					/* 
					 * Calculate the distance and other variables
					 * These variables are used to calculate the final color
					 */
					float d, e, f, g = 1.0 / 40.0 ,h ,i ,r ,q;

					/* 
					 * Calculate the x and y coordinates of the pixel
					 * These coordinates are used to calculate the final color
					 */
					e = 400.0 * ( p.x * 0.5 + 0.5 );
					f = 400.0 * ( p.y * 0.5 + 0.5 );

					/* 
					 * Calculate the final color of the pixel
					 * The final color is a 3-component vector (r, g, b)
					 */
					i = 200.0 + sin( e * g + a / 150.0 ) * 20.0;
					d = 200.0 + cos( f * g / 2.0 ) * 18.0 + cos( e * g ) * 7.0;
					r = sqrt( pow( abs( i - e ), 2.0 ) + pow( abs( d - f ), 2.0 ) );
					q = f / r;
					e = ( r * cos( q ) ) - a / 2.0;
					f = ( r * sin( q ) ) - a / 2.0;
					d = sin( e * g ) * 176.0 + sin( e * g ) * 164.0 + r;
					h = ( ( f + d ) + a / 2.0 ) * g;
					i = cos( h + r * p.x / 1.3 ) * ( e + e + a ) + cos( q * g * 6.0 ) * ( r + h / 3.0 );
					h = sin( f * g ) * 144.0 - sin( e * g ) * 212.0 * p.x;
					h = ( h + ( f - e ) * q + sin( r - ( a + h ) / 7.0 ) * 10.0 + i / 4.0 ) * g;
					i += cos( h * 2.3 * sin( a / 350.0 - q ) ) * 184.0 * sin( q - ( r * 4.3 + a / 12.0 ) * g ) + tan( r * g + h ) * 184.0 * cos( r * g + h );
					i = mod( i / 5.6, 256.0 ) / 64.0;
					if ( i < 0.0 ) i += 4.0;
					if ( i >= 2.0 ) i = 4.0 - i;
					d = r / 350.0;
					d += sin( d * d * 8.0 ) * 0.52;
					f = ( sin( a * g ) + 1.0 ) / 2.0;

					/* 
					 * Set the final color of the pixel
					 * The final color is a 4-component vector (r, g, b, a)
					 * where a is the alpha channel
					 */
					gl_FragColor = vec4( vec3( f * i / 1.6, i / 2.0 + d / 13.0, i ) * d * p.x + vec3( i / 1.3 + d / 8.0, i / 2.0 + d / 18.0, i ) * d * ( 1.0 - p.x ), 1.0 );

				}
			</script>

			<!-- Import map for three.js library -->
			<script type="importmap">
				{
					"imports": {
						"three": "https://unpkg.com/three@0.145.0/build/three.module.js",
						"three/addons/": "https://unpkg.com/three@0.145.0/examples/jsm/"
					}
				}
			</script>

			<!-- JavaScript code for the WebGL application -->
			<script type="module">
				// Import three.js library
				import * as THREE from 'three';

				// Global variables for the application
				let camera, scene, renderer;

				// Uniform variables for the shaders
				let uniforms;

				// Initialize the application
				init();

				/* 
				 * Initialize the application
				 * This function sets up the camera, scene, and renderer
				 */
				function init() {
					// Get the container element for the WebGL content
					const container = document.getElementById( 'container' );

					// Create the camera
					camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

					// Create the scene
					scene = new THREE.Scene();

					// Create the geometry for the plane
					const geometry = new THREE.PlaneGeometry( 2, 2 );

					// Create the uniform variables for the shaders
					uniforms = {
						time: { value: 1.0 }
					};

					// Create the material for the plane
					const material = new THREE.ShaderMaterial( {
						// Set the uniforms for the material
						uniforms: uniforms,

						// Set the vertex shader for the material
						vertexShader: document.getElementById( 'vertexShader' ).textContent,

						// Set the fragment shader for the material
						fragmentShader: document.getElementById( 'fragmentShader' ).textContent
					} );

					// Create the mesh for the plane
					const mesh = new THREE.Mesh( geometry, material );

					// Add the mesh to the scene
					scene.add( mesh );

					// Create the renderer
					renderer = new THREE.WebGLRenderer();

					// Set the pixel ratio for the renderer
					renderer.setPixelRatio( window.devicePixelRatio );

					// Set the size of the renderer
					renderer.setSize( window.innerWidth, window.innerHeight );

					// Set the animation loop for the renderer
					renderer.setAnimationLoop( animate );

					// Add the renderer to the container
					container.appendChild( renderer.domElement );

					// Add event listener for window resize
					window.addEventListener( 'resize', onWindowResize );
				}

				/* 
				 * Handle window resize event
				 * This function updates the size of the renderer
				 */
				function onWindowResize() {
					// Update the size of the renderer
					renderer.setSize( window.innerWidth, window.innerHeight );
				}

				/* 
				 * Animation loop function
				 * This function updates the uniforms and renders the scene
				 */
				function animate() {
					// Update the time uniform
					uniforms[ 'time' ].value = performance.now() / 1000;

					// Render the scene
					renderer.render( scene, camera );
				}
			</script>
			<script src="../menu.js"></script>
			<!-- Add Prism.js for syntax highlighting -->
			<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
			<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
		</body>
</html>
