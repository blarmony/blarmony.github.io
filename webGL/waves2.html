<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>WebGL Triple Double Waves</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; background: #101820; overflow: hidden; }
    #wavesCanvas { position: fixed; width: 100vw; height: 100vh; left: 0; top: 0; z-index: 0; display: block; }
    .description {
      position: absolute;
      top: 14px; left: 14px;
      background: rgba(16,24,32,0.7);
      color: #fff; padding: 10px 18px;
      border-radius: 7px; z-index: 1;
      font-size: 1.12em; font-family: sans-serif;
      max-width: 90vw;
    }
  </style>
</head>
<body>
  <canvas id="wavesCanvas"></canvas>
  <div class="description">
    This page features three gently animated double waves made by combining pairs of sine waves with different frequencies and amplitudes.
    Each row uses a unique color palette (green, turquoise, blue) and is accented by occasional yellow and orange highlights on the wave crests, creating a soothing oceanic background.
  </div>
  <script>
    // Get canvas and WebGL context
    const canvas = document.getElementById('wavesCanvas');
    const gl = canvas.getContext('webgl');
    let width = 0, height = 0, aspect = 1;

    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      aspect = width / height;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- GLSL Shaders ---
    const vertexShaderSource = `
      attribute float aX;
      attribute float aRow;
      uniform float uTime;
      uniform float uAspect;
      varying float vY;
      varying float vRow;
      varying float vCrest;

      void main() {
        float row = aRow;
        float x = aX;
        float y = 0.0;
        float baseY = -0.7 + row * 0.7; // -0.7, 0.0, +0.7

        // Row-specific double sine
        if(row < 0.5) {
          y = baseY
            + 0.10 * sin(1.7 * x + uTime * 0.55)
            + 0.06 * sin(5.2 * x - uTime * 0.75);
        } else if(row < 1.5) {
          y = baseY
            + 0.14 * sin(2.2 * x + uTime * 0.45)
            + 0.09 * sin(7.0 * x - uTime * 0.52);
        } else {
          y = baseY
            + 0.11 * sin(2.6 * x + uTime * 0.33)
            + 0.07 * sin(4.8 * x - uTime * 0.66);
        }
        float crest = (sin(8.0 * x + uTime * 0.7) + 1.0) * 0.5;
        vY = y;
        vRow = row;
        vCrest = crest;
        gl_Position = vec4(x * uAspect, y, 0.0, 1.0);
      }
    `;
    const fragmentShaderSource = `
      precision mediump float;
      varying float vY;
      varying float vRow;
      varying float vCrest;
      void main() {
        float alpha = 0.83;
        vec3 color;
        if(vRow < 0.5) {
          color = mix(vec3(0.11, 0.82, 0.3), vec3(0.16, 0.92, 0.45), 0.5 + 0.5 * vY);
        } else if(vRow < 1.5) {
          color = mix(vec3(0.08, 0.85, 0.82), vec3(0.15, 0.96, 0.91), 0.5 + 0.5 * vY);
        } else {
          color = mix(vec3(0.18, 0.45, 0.92), vec3(0.38, 0.72, 1.0), 0.5 + 0.5 * vY);
        }
        // Highlight crests with yellow/orange occasionally
        float crestHighlight = smoothstep(0.82, 1.0, vCrest);
        if(crestHighlight > 0.0 && mod(vY * 10.0 + vRow * 2.0, 2.0) > 1.6) {
          vec3 highlight = mix(vec3(1.0, 0.92, 0.36), vec3(1.0, 0.69, 0.22), step(0.5, vRow));
          color = mix(color, highlight, crestHighlight * 0.9);
          alpha = 1.0;
        }
        gl_FragColor = vec4(color, alpha);
      }
    `;

    // --- Shader Utilities ---
    function compileShader(gl, src, type) {
      const sh = gl.createShader(type);
      gl.shaderSource(sh, src);
      gl.compileShader(sh);
      if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(sh));
        throw new Error('Shader compile error');
      }
      return sh;
    }
    const vsh = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
    const fsh = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);

    const program = gl.createProgram();
    gl.attachShader(program, vsh);
    gl.attachShader(program, fsh);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(program));
      throw new Error('Shader link error');
    }
    gl.useProgram(program);

    // --- Attributes & Uniforms ---
    const aX = gl.getAttribLocation(program, 'aX');
    const aRow = gl.getAttribLocation(program, 'aRow');
    const uTime = gl.getUniformLocation(program, 'uTime');
    const uAspect = gl.getUniformLocation(program, 'uAspect');

    // --- Geometry ---
    const slices = 240, rows = 3;
    const xArr = [], rowArr = [], idxArr = [];
    for(let row=0; row<rows; ++row) {
      for(let i=0; i<=slices; ++i) {
        let x = -1 + 2*i/slices;
        xArr.push(x, x);
        rowArr.push(row, row);
      }
    }
    // Indices for strips
    for(let row=0; row<rows; ++row) {
      let offset = row*(slices+1)*2;
      for(let i=0; i<slices; ++i) {
        idxArr.push(offset+i*2, offset+i*2+1, offset+i*2+2);
        idxArr.push(offset+i*2+1, offset+i*2+2, offset+i*2+3);
      }
    }

    const xBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, xBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(xArr), gl.STATIC_DRAW);

    const rowBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, rowBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(rowArr), gl.STATIC_DRAW);

    const idxBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(idxArr), gl.STATIC_DRAW);

    // --- Draw Loop ---
    function render(t) {
      gl.clearColor(0.07, 0.10, 0.16, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.useProgram(program);
      gl.uniform1f(uTime, t * 0.001);
      gl.uniform1f(uAspect, aspect);

      // Attribute aX
      gl.enableVertexAttribArray(aX);
      gl.bindBuffer(gl.ARRAY_BUFFER, xBuffer);
      gl.vertexAttribPointer(aX, 1, gl.FLOAT, false, 0, 0);

      // Attribute aRow
      gl.enableVertexAttribArray(aRow);
      gl.bindBuffer(gl.ARRAY_BUFFER, rowBuffer);
      gl.vertexAttribPointer(aRow, 1, gl.FLOAT, false, 0, 0);

      // Indices
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuffer);
      gl.drawElements(gl.TRIANGLES, idxArr.length, gl.UNSIGNED_SHORT, 0);

      requestAnimationFrame(render);
    }
    render(0);
  </script>
</body>
</html>