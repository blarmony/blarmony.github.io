<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>WebGL Triple Double Waves</title>
    <style>
        html, body { 
            margin: 0; 
            padding: 0; 
            height: 100%; 
            background: #101820; 
            overflow: hidden; 
        }
        #wavesCanvas { 
            position: fixed; 
            width: 100vw; 
            height: 100vh; 
            left: 0; 
            top: 0;
            z-index: 0;
            display: block;
        }
        .description {
            position: absolute;
            top: 14px;
            left: 14px;
            background: rgba(16,24,32,0.7);
            color: #fff;
            padding: 10px 18px;
            border-radius: 7px;
            z-index: 1;
            font-size: 1.12em;
            font-family: sans-serif;
            max-width: 90vw;
        }
    </style>
</head>
<body>
    <canvas id="wavesCanvas"></canvas>
    <div class="description">
        This page features three gently animated double waves made by combining pairs of sine waves with different frequencies and amplitudes.
        Each row uses a unique color palette (green, turquoise, blue) and is accented by occasional yellow and orange highlights.
    </div>
    <script>
    (function() {
        // -- Canvas and GL setup --
        const canvas = document.getElementById('wavesCanvas');
        const gl = canvas.getContext('webgl2', { antialias: true, alpha: false }) || 
                  canvas.getContext('experimental-webgl2', { antialias: true, alpha: false }) ||
                  canvas.getContext('webgl', { antialias: true, alpha: false }) ||
                  canvas.getContext('experimental-webgl', { antialias: true, alpha: false });
        
        if (!gl) {
            alert('Unable to initialize WebGL. Your browser may not support it.');
            return;
        }

        // Enable required GL features
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);  // Added this line

        function resize() {
            // Get the display's pixel ratio
            const dpr = window.devicePixelRatio || 1;
            // Get the size of the canvas in CSS pixels
            const width = canvas.clientWidth * dpr;
            const height = canvas.clientHeight * dpr;
            
            // Check if the canvas is not the same size
            if (canvas.width !== width || canvas.height !== height) {
                // Make the canvas the same size
                canvas.width = width;
                canvas.height = height;
                // Set the viewport to match
                gl.viewport(0, 0, width, height);
            }
        }
        window.addEventListener('resize', resize);
        resize();

        // -- Shaders --
        const vertSrc = `
            precision highp float;
            attribute float aX;
            attribute float aRow;
            uniform float uTime;
            uniform float uAspect;
            varying float vRow;
            varying float vY;
            varying float vCrest;
            void main() {
                float x = aX;
                float baseY = -0.7 + aRow * 0.7;
                float y;
                // Double sine per row
                if(aRow < 0.5) {
                    y = baseY + 0.10*sin(1.7*x + uTime*0.55) + 0.06*sin(5.2*x - uTime*0.75);
                } else if(aRow < 1.5) {
                    y = baseY + 0.14*sin(2.2*x + uTime*0.45) + 0.09*sin(7.0*x - uTime*0.52);
                } else {
                    y = baseY + 0.11*sin(2.6*x + uTime*0.33) + 0.07*sin(4.8*x - uTime*0.66);
                }
                float crest = (sin(8.0*x + uTime * 0.7) + 1.0) * 0.5;
                vRow = aRow;
                vY = y;
                vCrest = crest;
                
                // Set the final position
                vec2 pos = vec2(x, y);
                if (uAspect > 1.0) {
                    pos.x /= uAspect;
                } else {
                    pos.y *= uAspect;
                }
                gl_Position = vec4(pos, 0.0, 1.0);
                gl_PointSize = 2.0;
            }
        `;

        const fragSrc = `
            precision highp float;
            varying float vRow;
            varying float vY;
            varying float vCrest;
            
            void main() {
                float alpha = 0.88;
                vec3 color;
                
                // Set base colors for each row
                if(vRow < 0.5) {
                    color = mix(vec3(0.13, 0.88, 0.38), vec3(0.23, 1.0, 0.41), 0.5 + 0.5 * vY);
                } else if(vRow < 1.5) {
                    color = mix(vec3(0.10, 0.85, 0.82), vec3(0.20, 1.0, 0.91), 0.5 + 0.5 * vY);
                } else {
                    color = mix(vec3(0.22, 0.55, 1.0), vec3(0.24, 0.88, 1.0), 0.5 + 0.5 * vY);
                }
                
                // Add highlights to wave crests
                float crestHighlight = smoothstep(0.82, 1.0, vCrest);
                if(crestHighlight > 0.0) {
                    vec3 highlight = mix(
                        vec3(1.0, 0.92, 0.36),  // Yellow
                        vec3(1.0, 0.69, 0.22),  // Orange
                        step(0.5, vRow)
                    );
                    color = mix(color, highlight, crestHighlight * 0.9);
                    alpha = 1.0;
                }
                
                // Ensure we don't render transparent pixels
                if (alpha < 0.01) discard;
                
                gl_FragColor = vec4(color, alpha);
            }
        `;

        function compile(gl, src, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, src);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertShader = compile(gl, vertSrc, gl.VERTEX_SHADER);
        const fragShader = compile(gl, fragSrc, gl.FRAGMENT_SHADER);
        if (!vertShader || !fragShader) {
            console.error('Shader compilation failed');
            return;
        }

        const program = gl.createProgram();
        gl.attachShader(program, vertShader);
        gl.attachShader(program, fragShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(program));
            return;
        }

        gl.useProgram(program);

        // -- Attributes & Uniforms --
        const aXLoc = gl.getAttribLocation(program, "aX");
        const aRowLoc = gl.getAttribLocation(program, "aRow");
        const uTimeLoc = gl.getUniformLocation(program, "uTime");
        const uAspectLoc = gl.getUniformLocation(program, "uAspect");

        // -- Geometry Preparation --
        const slices = 240, rows = 3;
        const xArr = [], rowArr = [];
        
        // Create positions for each row
        for(let row = 0; row < rows; ++row) {
            for(let i = 0; i <= slices; ++i) {
                const x = -1 + 2 * i / slices;
                xArr.push(x);
                rowArr.push(row);
            }
        }

        // Create and fill position buffer
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(xArr), gl.STATIC_DRAW);

        // Create and fill row buffer
        const rowBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, rowBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(rowArr), gl.STATIC_DRAW);

        // Set up vertex attributes
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(aXLoc, 1, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(aXLoc);
        
        gl.bindBuffer(gl.ARRAY_BUFFER, rowBuffer);
        gl.vertexAttribPointer(aRowLoc, 1, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(aRowLoc);

        // -- Animation loop --
        function render(time) {
            resize();
            
            // Clear the canvas
            gl.clearColor(0.07, 0.10, 0.16, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            // Use our shader program
            gl.useProgram(program);
            
            // Update uniforms
            gl.uniform1f(uTimeLoc, time * 0.001);
            gl.uniform1f(uAspectLoc, canvas.width / canvas.height);
            
            // Draw each row as a line strip
            gl.lineWidth(2.0);
            const pointsPerRow = slices + 1;
            
            for (let row = 0; row < rows; row++) {
                const offset = row * pointsPerRow;
                gl.drawArrays(gl.LINE_STRIP, offset, pointsPerRow);
            }
            
            // Continue the animation loop
            requestAnimationFrame(render);
        }

        // Start the animation
        requestAnimationFrame(render);
    })();
    </script>
</body>
</html>