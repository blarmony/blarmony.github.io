<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebGL Mountain Landscape</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
      color: white;
      background: black;
    }
    canvas {
      display: block;
    }
    .description {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <div class="description">
    This webpage features an animated WebGL background of a vast mountainous landscape, defined by green lines. The camera flies over the terrain, looking down, with the far horizon near the top of the viewport.
  </div>
  <canvas id="webglCanvas"></canvas>
  <script>
    const canvas = document.getElementById('webglCanvas');
    const gl = canvas.getContext('webgl');

    if (!gl) {
      alert('WebGL not supported, please use a different browser.');
    }
    
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const vertexShaderSource = `
      attribute vec3 coordinates;
      uniform mat4 projectionMatrix;
      uniform mat4 modelViewMatrix;
      void main(void) {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(coordinates, 1.0);
      }
    `;

    const fragmentShaderSource = `
      precision mediump float;
      void main(void) {
        gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);
      }
    `;

    function createShader(gl, sourceCode, type) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, sourceCode);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    const vertexShader = createShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
    const fragmentShader = createShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);

    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(shaderProgram));
      return;
    }

    gl.useProgram(shaderProgram);

    const coordinates = [];
    const gridSize = 100;
    const gridSpacing = 0.2;

    for (let x = -gridSize; x < gridSize; x++) {
      for (let z = -gridSize; z < gridSize; z++) {
        coordinates.push(x * gridSpacing, Math.sin(x) * 0.1, z * gridSpacing);
        coordinates.push((x + 1) * gridSpacing, Math.sin(x + 1) * 0.1, z * gridSpacing);
      }
    }

    const coordinateBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, coordinateBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(coordinates), gl.STATIC_DRAW);

    const coordinatesAttributeLocation = gl.getAttribLocation(shaderProgram, 'coordinates');
    gl.enableVertexAttribArray(coordinatesAttributeLocation);
    gl.vertexAttribPointer(coordinatesAttributeLocation, 3, gl.FLOAT, false, 0, 0);

    const projectionMatrixLocation = gl.getUniformLocation(shaderProgram, 'projectionMatrix');
    const modelViewMatrixLocation = gl.getUniformLocation(shaderProgram, 'modelViewMatrix');

    const projectionMatrix = mat4.create();
    mat4.perspective(projectionMatrix, Math.PI / 4, canvas.width / canvas.height, 0.1, 1000.0);

    let modelViewMatrix = mat4.create();
    mat4.lookAt(modelViewMatrix, [0, 1, 5], [0, 0, 0], [0, 1, 0]);

    function render() {
      mat4.translate(modelViewMatrix, modelViewMatrix, [0, 0, -0.1]); // Move forward

      gl.uniformMatrix4fv(projectionMatrixLocation, false, projectionMatrix);
      gl.uniformMatrix4fv(modelViewMatrixLocation, false, modelViewMatrix);

      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      gl.drawArrays(gl.LINES, 0, coordinates.length / 3);

      requestAnimationFrame(render);
    }

    render();
  </script>
</body>
</html>